## 问题描述
输入：整数序列
$a_1, a_2, …, a_n $

输出：序列的一个子段，其和最大
$$\sum_{k=i}^j a_k$$

注意：当所有整数都为负数时，定义最大子段和为0
## 解题思路
该问题满足最优性原理，可以用动态规划的方法进行求解。我们采用后向推断方法。具体解题思路如下：

序列里面的每个元素都依次被作为子序列的右边界进行计算求解。

（1）若以
$a_i$
为右边界的子段最大和小于等于0，则舍弃i之前的所有数；

（2）若以
$a_i$
为右边界的子段最大和大于0，则暂时先将
$a_i$
加入到最大和子段中；

（3）把当前的子段和与最大子段和比较，若大于最大子段和则更新最大子段和，小于则最大子段和仍然保持原来的数；

（4）最后根据所求的最大子段和回溯得到对应子段。

假设：
$b_j$
表示从
$a_1$
到
$a_j$
(前 j 项)中，包含
$a_j$
的最大的子段和。

由
$b_j$
的定义易知，当
$b_{j-1}>0 $
时
$b_j=b_{j-1}+a_j$
，否则
$b_j=a_j$
。

由此可得计算
$b_j$
的动态规划递归式
$$b_j=max \lbrace b_{j-1}+a_j，a_j \rbrace，1≤j≤n$$

最终求得的最大子段和为：
$max\lbrace b_j \rbrace$


## 举例说明

    输入：[-1, 2, 5, 4, -7, 6, 8, -2]
    以-1为右边界的子段和最大为0；  -1
    以2为右边界的子段和最大为2；   2
    以5为右边界的子段和最大为7；   2，5
    以4为右边界的子段和最大为11；  2，5，4
    以-7为右边界的子段和最大为11； 2，5，4
    以6为右边界的子段和最大为11；  2，5，4
    以8为右边界的子段和最大为18；  2，5，4，-7，6，8
    以-2为右边界的子段和最大为18； 2，5，4，-7，6，8

## 代码

    def max_sum(list):
        sum = 0
        max = 0
        for i in range(len(list)):
            if sum < 0:
                # 如果添加元素前，序列的子段最大和为负，那么不管即将添加的元素为多少，
                # 都只需要将之前的子序列舍弃，直接取该元素的值作为新序列的子段最大和
                sum = list[i]
            else:
                # 如果添加元素前，序列的子段最大和为正，则可暂时加上该元素
                sum += list[i]
            if max < sum:
                max = sum
        return max


    if __name__ == '__main__':
        list = [-1, 2, 5, 4, -7, 6, 8, -2]
        print(max_sum(list))

